\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\title{Core Concepts}
\order{3}
\begin{document}




\section{Core Concepts and Terminology}

This section introduces the key notions you will encounter when using the Hyperon Pattern Miner.  We illustrate with actual MeTTa functions and modules from the \texttt{hyperon-miner} repository.

\subsection{AtomSpace}

The \textbf{AtomSpace} is Hyperon's persistent metagraph store.  Every node and link you mine lives there.  In MeTTa you typically create or bind an AtomSpace via:

\begin{verbatim}
!(import! &self hyperon-miner:match:MinerMatch)
!(bind! &atom-space (new-space)) 
\end{verbatim}

Atoms you insert may be of various types, such as

\begin{itemize}
  \item \texttt{ConceptNode}: \verb|Coke|
  \item \texttt{LinkNode}: \verb|drink|
  \item \texttt{VariableNode}:  \verb|$X|
  \item \texttt{InheritanceLink}: 
    \verb|(Inheritance $X American)|
  \item \texttt{EvaluationLink}:  
    \verb|(drink $X Coke)|
\end{itemize}

\subsection{Abstract vs. Specialized Patterns}

The miner distinguishes between \emph{abstract} and \emph{specialized} patterns:

\begin{enumerate}
  \item \textbf{Abstract patterns}
  Generated by scanning for unique link nodes and creating a pattern with the link node and Variable nodes and checking for the support of the pattern generated to see if it satisfies the minimum support threshold to prevent an abstract pattern that doesn't satisfy the minimum support threshold from being specialized.  Implemented by the \texttt{abstract-pattern} logic in \texttt{experiments/rules/frequent-pattern-miner.metta}
    \begin{verbatim}
;; returns abstract patterns
!(abstract-pattern $dbspace $minsup $aptrnspace)
    \end{verbatim}
  \item \textbf{Specialized patterns}
    Each abstract pattern is ''specialized'' by composing a variable with shallow abstractions of its groundings/valuations/substitutions.  This is done in \texttt{experiments/rules/build-specialization.metta} using the \texttt{build-specialization} function.
\end{enumerate}

We now look at some examples of each of these.

\subsubsection{Abstract Patterns}

Below are two concrete examples showing how a ground link is turned into Abstract patterns.

\paragraph{Example 1:}

Suppose the AtomSpace contains the ground atom:

\begin{verbatim}
(drink Alice Coke)
\end{verbatim}

The abstract pattern generated by \texttt{(abstract-pattern)} is:

\begin{verbatim}
(drink $x $y)
\end{verbatim}

\paragraph{Example 2:}

Given the ground atom:

\begin{verbatim}
(inherit Alice American)
\end{verbatim}

The abstract pattern generated is:

\begin{verbatim}
(inherit $x $y)
\end{verbatim}

To check it out first load the neccessary components.


\begin{verbatim}
!(import! &self hyperon-miner:experiments:rules:frequent-pattern-miner)
!(import! &self hyperon-miner:experiments:utils:common-utils)
\end{verbatim}

Create new atom space and load some ground atoms.


\begin{verbatim}
;; create db space 
!(bind! &db (new-space))
!(add-reduct &db (superpose ((drink Alice Coke)
                                   (drink Bob Coke)
                                    (drink Carol Tea))))
;;Create a new space for the result                                   
!(bind! &aptrnspace (new-space))
\end{verbatim}

    \begin{verbatim}
;; returns abstract patterns
!(abstract-pattern &db 2 &aptrnspace)
!(match &aptrnspace $x $x )
    \end{verbatim}

\subsubsection{Examples of Specialized Patterns}

Below are two concrete examples showing how an \texttt{abstract} pattern is turned into \texttt{specialized} patterns via the \texttt{build-specialization} function.

\paragraph{Example 1: Drink Pattern}

Suppose your AtomSpace contains these ground atoms:

\begin{verbatim}
(drink Alice Coke)
(drink Bob Coke)
(drink Carol Tea)
\end{verbatim}

We can then

\begin{enumerate}
\item  Define the abstract pattern:
    \begin{verbatim}
 (=(p_abs)(drink $X $Y))
    \end{verbatim}
\item  Specialize to get each grounding:
    \begin{verbatim}
    (specialize atom-space (p_abs))
     ;; The result would look like 
         (SpecializationOf (drink Alice $Y) (drink $x $y))
         (SpecializationOf (drink Bob $Y) (drink $x $y))
         (SpecializationOf (drink $X Coke)  (drink $x $y))
         (SpecializationOf (drink $X Tea) (drink $x $y))
    \end{verbatim}
\item   Group and count via support:
    \begin{verbatim}
(support p_spec 2)
    \end{verbatim}
    This indicates the pattern ''drinks \$X  Coke'' occurs twice.
\end{enumerate}

Now let's try it with the actual build-specialization function.
First, import the build-specialization component and create a new space to store the result.

 \begin{verbatim}
!(import! &self hyperon-miner:experiments:rules:build-specialization)
!(bind! &specspace (new-space))
  \end{verbatim}

Since we have obtained the abstract pattern from our previous example, we can provide it  to the function.

 \begin{verbatim}
;;returns all possible specializations of the abstract pattern
!(build-specialization (drink Z (S Z)) &db &specspace)
!(match &specspace $x $x)
  \end{verbatim}



\subsection{Candidate Patterns and Support}

A \emph{candidate pattern} is any specialized pattern whose \emph{support} \space{0.2rem} \textbf{match-count} meets your minimum threshold:

import the candidate-patterns function and create a new space to store the result.

 \begin{verbatim}
!(import! &self hyperon-miner:experiments:rules:candidate-patterns)
!(bind! &cndpspace (new-space))
  \end{verbatim}

\begin{verbatim}
!(candidatePattern &db &specspace 2 &cndpspace)
!(match &cndpspace $x $x)
\end{verbatim}

Here:\\

\begin{itemize}
  \item \texttt{minsup} is the minimum support parameter.
  \item \texttt{support} invokes \texttt{count} and filters out patterns with count < \texttt{minsup}.
\end{itemize}

\subsection{Conjunction and Pattern Expansion}

To discover richer structures, surviving patterns are greedily expanded by conjunction:

 \begin{verbatim}
!(import! &self hyperon-miner:experiments:rules:conjunction-expansion)
!(bind! &conjspace (new-space))
  \end{verbatim}

\begin{verbatim}
!(do-conjunct  &db &cndpspace  &conjspace 2 )
!(match &conjspace $x $x)
\end{verbatim}

\texttt{expand_conjunction} (in \texttt{experiments/rules/conjunction-expansion.metta}) pairs patterns by creating common variables between them to form multi-clause \verb|(and ...)| expressions.  Iterating with increasing depth yields N-clause patterns.

\subsection{Surprisingness (Interestingness)}

Once you have frequent $n$-clause patterns, you rank them by \emph{I-Surprisingness}, which measures how much a pattern?s observed probability deviates from its expected probability under a simple independence assumption.  

In more detail:

\begin{verbatim}
;; Compute I-Surprisingness of a pattern
(= (iSurprisingness pattern)
  ;; pattern = (candidate clauses count)
  (let* ((clauses   (get-clauses pattern))    ; list of atomic clauses
         (obs-count (get-count   pattern))    ; number of matches
         (Z         (universe-size))         ; total atoms
         (p_obs     (/ obs-count Z))         ; observed probability
         (p_exp     (compute-expected clauses Z))) ; expected under independence
    ;; return normalized absolute deviation
    (/ (abs (- p_obs p_exp))
       p_obs)))
;; Expected probability for 2-clause patterns:
(= (compute-expected (list c1 c2) Z)
  (* (/ (match-count c1) Z)
     (/ (match-count c2) Z)))
;; Expected probability for 3-clause patterns:
(= (compute-expected (list c1 c2 c3) Z)
  (let* ((p1    (/ (match-count c1) Z))
         (p2    (/ (match-count c2) Z))
         (p3    (/ (match-count c3) Z))
         ;; pairwise block probabilities
         (p12   (* p1 p2))
         (p13   (* p1 p3))
         (p23   (* p2 p3))
         ;; choose the most extreme block probability
         (p_max (max p12 p13 p23))
         (p_min (min p12 p13 p23)))
    ;; worst-case deviation from observed
    (max p_max p_min)))
\end{verbatim}

\paragraph{Explanation of steps}

\begin{enumerate}
  \item Compute \texttt{Z = universe-size}, the total number of atoms in the AtomSpace.
  \item For a pattern with support \texttt{obs-count}, compute its observed probability
        \[
          p_{\rm obs} = \frac{\text{obs-count}}{Z}.
        \]
  \item Compute the expected probability \texttt{p\_exp} by assuming each clause is independent:
   \begin{itemize}
    \item For two clauses  ${c_1,c_2}$:
      $$p_{\rm exp} = P(c_1)\times P(c_2).$$
    \item For three clauses ${c_1,c_2,c_3\}$, consider the pairwise block probabilities
      $P(c_i)\,P(c_j)$ for each pair, take the maximum and minimum of these, and use the one that yields the largest deviation.
  \end{itemize} 
  \item Finally, compute the normalized absolute deviation
        $$
          I = \frac{\lvert p_{\rm obs} - p_{\rm exp}\rvert}{p_{\rm obs}}.
        $$
\end{enumerate}

You can then filter patterns by a surprisingness threshold \texttt{highsurp} using the high?level call:

\begin{verbatim}
(miner-surprising atom-space minsup max-clauses highsurp)
\end{verbatim}

which returns only those patterns with $I>$ \texttt{highsurp}.

\end{document}